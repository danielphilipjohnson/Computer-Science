# Coding project

## Fully understand the problem statement

The first step to handle any coding project is to fully understand the problem statement. This includes; spelling out what needs to
be done and identifying what the given inputs and desired outputs are for that program that we need to write. 

## Research 
we recommend doing some research. This means figuring out how we can tackle the problem by the tools
provided by the Python standard library or by external modules. 

This research phase also includes looking at the documentation of the modules, classes, and functions that we'll need to use,
and understanding how they should be applied. 


## Planning (Design Document)
Once we know what we need to write and what tools we can use to make it work, we should do some planning. This means thinking about what
data types are useful for our solution, the order of operations that we need to perform, and how all the pieces have
come together to form our solution. Synergy. If the problem is complex, it might help to write down the plan for quick reference,
either on a piece of paper or in a digital document. Writing down the plan helps us focus on how we're going to do
things and identify any problems our plan might have. At many companies, it's a common practice to write a design document at this stage, 

## Writing the Script
Finally, once we have a clear plan, we do the actual writing of the script. This step includes not only writing the code, but also checking that
the code does what it's supposed to do. We do that by both manually testing the code and adding some automatic test. 


## Problem Statement
Final project in this course, you'll write some automation scripts that will process the system log and generate a bunch of reports 
based on the information extracted from log files. The log lines follow a pattern similar to the ones we've seen before. 


When the service runs correctly, it logs an info message to syslog,stating what it's done, the username, 
and the ticket number related to the event.

### ERROR STAMP

Jun 1 11:06:48 ubuntu.local ticky: ERROR: Connection to DB failed (username)


### Types of error:

- Timeout while retrieving information
- The ticket was modified while updating
- Connection to DB failed
- Tried to add information to a closed ticket
- Permission denied while closing ticket
- Ticket doesn't exist

### BASH command to fetch all errors
-------------------------------
` grep "ERROR" syslog.log



### Specific ERROR  with BASH
------------------------------
`grep "ERROR Tried to add information to closed ticket" syslog.log


If the service encounters a problem, it logs in error message to the syslog, indicating what was wrong and the username that triggered the action that caused the problem.

The developers of the service want two different reports out of this data. 
1. The first one is a ranking of errors generated by the system. This means a list of all error messages logged, and how many times each of them was found, not taking into account the users involved. They should be sorted by the most common error to the least common error. 

2. The second one is a usage statistics for the service. This means, a list of all users that have used the system including how many info messages and how many error messages they've generated. This report should be sorted by username. To visualize the data in these reports, you want to generate a couple of webpages that'll be served by a web server running on the machine. To do this, you can make use of a script that's already in the system called csv_ to_html.py.  This  script converts the data in a CSV file into an HTML file containing a table with the data. Then, put the files in the directory   that's used by the webserver to display the webpages. 


The goal is to have one script that can get all the necessary work done automatically, every day without any user interaction. This script doesn't need to do all the work itself. It can call on other scripts to do individual task and then put the results together. In fact, we recommend splitting the task so that each piece can be written and tested separately. 
